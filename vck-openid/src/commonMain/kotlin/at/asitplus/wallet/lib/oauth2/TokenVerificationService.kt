package at.asitplus.wallet.lib.oauth2

import at.asitplus.KmmResult
import at.asitplus.catching
import at.asitplus.iso.sha256
import at.asitplus.openid.OpenIdAuthorizationDetails
import at.asitplus.openid.OpenIdConstants.TOKEN_PREFIX_BEARER
import at.asitplus.openid.OpenIdConstants.TOKEN_PREFIX_DPOP
import at.asitplus.openid.OpenIdConstants.TOKEN_TYPE_BEARER
import at.asitplus.openid.OpenIdConstants.TOKEN_TYPE_DPOP
import at.asitplus.signum.indispensable.io.Base64UrlStrict
import at.asitplus.signum.indispensable.josef.JsonWebKey
import at.asitplus.signum.indispensable.josef.JsonWebToken
import at.asitplus.signum.indispensable.josef.JwsSigned
import at.asitplus.wallet.lib.data.vckJsonSerializer
import at.asitplus.wallet.lib.jws.JwsContentTypeConstants
import at.asitplus.wallet.lib.jws.VerifyJwsObject
import at.asitplus.wallet.lib.jws.VerifyJwsObjectFun
import at.asitplus.wallet.lib.jws.VerifyJwsSignatureWithKey
import at.asitplus.wallet.lib.jws.VerifyJwsSignatureWithKeyFun
import at.asitplus.wallet.lib.DefaultNonceService
import at.asitplus.wallet.lib.NonceService
import at.asitplus.wallet.lib.oidvci.OAuth2Exception.*
import at.asitplus.wallet.lib.oidvci.TokenInfo
import io.matthewnelson.encoding.core.Encoder.Companion.encodeToString
import kotlin.time.Clock
import kotlin.time.Clock.System
import kotlin.time.Duration
import kotlin.time.Duration.Companion.minutes


/**
 * Verifies access tokens and refresh tokens, that may have been generated by a [TokenGenerationService],
 * or by any other OAuth 2.0 authorization server.
 */
interface TokenVerificationService {

    /** Validates that this refresh token was actually issued by the known [TokenGenerationService]. */
    suspend fun validateRefreshToken(
        refreshToken: String,
        httpRequest: RequestInfo?,
        validatedClientKey: JsonWebKey?,
    ): String

    /** Reads information about the token contained in [tokenOrAuthHeader] for token introspection. */
    suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo

    /** Validates the token (either plain token or from an HTTP `Authorization` header, i.e., with prefix). */
    suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
        dpopNonceService: NonceService? = null,
    ): KmmResult<Unit>

    /** Validate a DPoP proof and extract the client's key if the proof exists at all. */
    suspend fun extractValidatedClientKey(
        httpRequest: RequestInfo?,
    ): KmmResult<JsonWebKey?>
}

/**
 * Verifies JWT tokens that have been generated by [JwtTokenGenerationService], as [OpenId4VciAccessToken].
 *
 * Implemented from
 * [OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)
 */
class JwtTokenVerificationService(
    /** Used to verify nonces of tokens created by the token generation service. */
    private val nonceService: NonceService,
    /** Used to verify nonces for DPoP proofs of clients. */
    internal val dpopNonceService: NonceService = DefaultNonceService(),
    /** Used to verify the signature of the DPoP access token. */
    private val issuerKey: JsonWebKey,
    /** Used to verify client attestation JWTs */
    private val verifyJwsObject: VerifyJwsObjectFun = VerifyJwsObject(),
    /** Used to verify DPoP proofs */
    private val verifyJwsSignatureWithKey: VerifyJwsSignatureWithKeyFun = VerifyJwsSignatureWithKey(),
    /** Clock used to verify timestamps in access tokens and refresh tokens. */
    private val clock: Clock = System,
    /** Time leeway for verification of timestamps in access tokens and refresh tokens. */
    private val timeLeeway: Duration = 5.minutes,
) : TokenVerificationService {

    override suspend fun validateRefreshToken(
        refreshToken: String,
        httpRequest: RequestInfo?,
        validatedClientKey: JsonWebKey?,
    ): String {
        val tokenJwt = validateToken(refreshToken, JwsContentTypeConstants.RT_JWT)
        // ath is not required on /token endpoints
        validateDpopProof(null, tokenJwt, httpRequest, dpopNonceService, validatedClientKey)
        return refreshToken
    }

    override suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo = run {
        val accessToken = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_DPOP, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_DPOP).split(" ").last()
        else tokenOrAuthHeader
        val tokenJwt = validateToken(accessToken, JwsContentTypeConstants.OID4VCI_AT_JWT)
        if (tokenJwt.payload.jwtId == null)
            throw InvalidToken("access token not valid: $accessToken")
        // No need to validate DPoP JWT, because we are not granting access to anything, just printing infos
        with(tokenJwt.payload) {
            TokenInfo(
                token = accessToken,
                authorizationDetails = authorizationDetails?.filterIsInstance<OpenIdAuthorizationDetails>()?.toSet(),
                scope = scope
            )
        }
    }

    override suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
        dpopNonceService: NonceService?,
    ) = catching {
        val accessToken = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_DPOP, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_DPOP).split(" ").last()
        else tokenOrAuthHeader
        val tokenJwt = validateToken(accessToken, JwsContentTypeConstants.OID4VCI_AT_JWT)
        validateDpopProof(accessToken, tokenJwt, httpRequest, dpopNonceService ?: this.dpopNonceService, null)
    }

    /** Validate a DPoP proof and extract the client's key if the proof exists at all. */
    override suspend fun extractValidatedClientKey(
        httpRequest: RequestInfo?,
    ): KmmResult<JsonWebKey?> = catching {
        if (httpRequest?.dpop.isNullOrEmpty()) {
            throw InvalidDpopProof("no dpop proof in header")
        }
        val dpopProof = httpRequest.dpop.parseDpopProof()
        if (dpopProof.header.type != JwsContentTypeConstants.DPOP_JWT) {
            throw InvalidDpopProof("invalid type: ${dpopProof.header.type}")
        }
        if (dpopProof.payload.nonce == null || !dpopNonceService.verifyAndRemoveNonce(dpopProof.payload.nonce!!)) {
            throw UseDpopNonce(dpopNonceService.provideNonce(), "DPoP JWT nonce not valid: ${dpopProof.payload.nonce}")
        }
        if (dpopProof.payload.httpTargetUrl != httpRequest.url) {
            throw InvalidDpopProof("DPoP JWT htu incorrect: ${dpopProof.payload.httpTargetUrl}")
        }
        if (dpopProof.payload.httpMethod != httpRequest.method.value.uppercase()) {
            throw InvalidDpopProof("DPoP JWT htm incorrect: ${dpopProof.payload.httpMethod}")
        }
        dpopProof.header.jsonWebKey
            ?: throw InvalidDpopProof("DPoP JWT contains no public key")

    }

    /** @param validatedClientKey the key from the extracted DPoP proof */
    internal suspend fun validateDpopProof(
        accessToken: String?,
        tokenJwt: JwsSigned<OpenId4VciAccessToken>,
        httpRequest: RequestInfo?,
        dpopNonceService: NonceService,
        validatedClientKey: JsonWebKey?,
    ) {
        if (httpRequest?.dpop.isNullOrEmpty()) {
            throw InvalidDpopProof("no dpop proof in header")
        }
        val dpopProof = httpRequest.dpop.parseDpopProof()
        if (dpopProof.header.type != JwsContentTypeConstants.DPOP_JWT) {
            throw InvalidDpopProof("invalid type: ${dpopProof.header.type}")
        }

        val jwkThumbprintFromToken = tokenJwt.payload.confirmationClaim!!.jsonWebKeyThumbprint
        if (tokenJwt.payload.confirmationClaim == null ||
            dpopProof.header.jsonWebKey == null ||
            dpopProof.header.jsonWebKey!!.jwkThumbprintPlain != jwkThumbprintFromToken
        ) {
            throw InvalidDpopProof("DPoP JWT JWK not matching cnf.jkt")
        }
        if (validatedClientKey != null) {
            if (jwkThumbprintFromToken != validatedClientKey.jwkThumbprintPlain) {
                throw InvalidDpopProof(
                    "Key from client ${validatedClientKey.jwkThumbprintPlain}" +
                            "not matching key from token $jwkThumbprintFromToken"
                )
            }
        } else {
            // DPoP-JWT has already been verified, so we can't check for the nonce twice
            if (dpopProof.payload.nonce == null || !dpopNonceService.verifyAndRemoveNonce(dpopProof.payload.nonce!!)) {
                throw UseDpopNonce(
                    dpopNonceService.provideNonce(),
                    "DPoP JWT nonce not valid: ${dpopProof.payload.nonce}"
                )
            }
        }
        if (dpopProof.payload.httpTargetUrl != httpRequest.url) {
            throw InvalidDpopProof("DPoP JWT htu incorrect: ${dpopProof.payload.httpTargetUrl}")
        }
        if (dpopProof.payload.httpMethod != httpRequest.method.value.uppercase()) {
            throw InvalidDpopProof("DPoP JWT htm incorrect: ${dpopProof.payload.httpMethod}")
        }
        accessToken?.let {
            val ath = accessToken.encodeToByteArray().sha256().encodeToString(Base64UrlStrict)
            if (!dpopProof.payload.accessTokenHash.equals(ath)) {
                throw InvalidDpopProof("DPoP JWT ath not correct: ${dpopProof.payload.accessTokenHash}, expected $ath")
            }
        }
    }

    private suspend fun String.parseDpopProof(): JwsSigned<JsonWebToken> =
        JwsSigned.deserialize(JsonWebToken.serializer(), this, vckJsonSerializer).getOrElse {
            throw InvalidDpopProof("could not parse DPoP JWT", it)
        }.also {
            if (!verifyJwsObject(it)) {
                throw InvalidDpopProof("DPoP JWT not verified")
            }
        }

    internal suspend fun validateToken(
        accessToken: String,
        expectedType: String,
    ): JwsSigned<OpenId4VciAccessToken> {
        val jwt = JwsSigned.deserialize(OpenId4VciAccessToken.serializer(), accessToken, vckJsonSerializer)
            .getOrElse { throw InvalidToken("could not parse DPoP Token", it) }
        verifyJwsSignatureWithKey(jwt, issuerKey).getOrElse {
            throw InvalidToken("DPoP Token not verified")
        }
        if (jwt.header.type != expectedType) {
            throw InvalidToken("typ not valid: ${jwt.header.type}")
        }
        if (jwt.payload.jwtId == null || !nonceService.verifyNonce(jwt.payload.jwtId!!)) {
            throw InvalidToken("jti not valid: ${jwt.payload.jwtId}")
        }
        if (jwt.payload.notBefore == null || jwt.payload.notBefore!! > (clock.now() + timeLeeway)) {
            throw InvalidToken("nbf not valid: ${jwt.payload.notBefore}")
        }
        if (jwt.payload.expiration == null || jwt.payload.expiration!! < (clock.now() - timeLeeway)) {
            throw InvalidToken("exp not valid: ${jwt.payload.expiration}")
        }
        if (jwt.payload.confirmationClaim == null) {
            throw InvalidToken("no confirmation claim")
        }
        return jwt
    }

    private val JsonWebKey.jwkThumbprintPlain
        get() = this.jwkThumbprint.removePrefix("urn:ietf:params:oauth:jwk-thumbprint:sha256:")

}

/**
 * Verifies Bearer tokens that have been generated by [BearerTokenGenerationService].
 * This does only work for internal authorization servers, because we could not store the actual user data otherwise.
 */
class BearerTokenVerificationService(
    /** Loads the actual user data with [BearerTokenGenerationService.getValidatedAccessToken]. */
    internal val tokenGenerationService: BearerTokenGenerationService,
) : TokenVerificationService {

    override suspend fun validateRefreshToken(
        refreshToken: String,
        httpRequest: RequestInfo?,
        validatedClientKey: JsonWebKey?,
    ): String {
        throw InvalidToken("Refresh tokens are not supported by this verifier")
    }

    /** Not supported for Bearer tokens. */
    override suspend fun extractValidatedClientKey(httpRequest: RequestInfo?) = catching { null }

    override suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
        dpopNonceService: NonceService?,
    ): KmmResult<Unit> = catching { getTokenInfo(tokenOrAuthHeader) }

    override suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo = run {
        val token = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_BEARER, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_BEARER).split(" ").last()
        else tokenOrAuthHeader
        tokenGenerationService.verifyAccessToken(token)?.toTokenInfo()
            ?: throw InvalidToken("authorization header not valid: $tokenOrAuthHeader")
    }
}
