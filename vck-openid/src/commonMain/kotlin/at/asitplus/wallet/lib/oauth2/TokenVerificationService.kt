package at.asitplus.wallet.lib.oauth2

import at.asitplus.KmmResult
import at.asitplus.catching
import at.asitplus.iso.sha256
import at.asitplus.openid.OpenIdAuthorizationDetails
import at.asitplus.openid.OpenIdConstants.TOKEN_PREFIX_BEARER
import at.asitplus.openid.OpenIdConstants.TOKEN_PREFIX_DPOP
import at.asitplus.openid.OpenIdConstants.TOKEN_TYPE_BEARER
import at.asitplus.openid.OpenIdConstants.TOKEN_TYPE_DPOP
import at.asitplus.signum.indispensable.io.Base64UrlStrict
import at.asitplus.signum.indispensable.josef.JsonWebKey
import at.asitplus.signum.indispensable.josef.JsonWebToken
import at.asitplus.signum.indispensable.josef.JwsSigned
import at.asitplus.wallet.lib.data.vckJsonSerializer
import at.asitplus.wallet.lib.jws.JwsContentTypeConstants
import at.asitplus.wallet.lib.jws.VerifyJwsObject
import at.asitplus.wallet.lib.jws.VerifyJwsObjectFun
import at.asitplus.wallet.lib.jws.VerifyJwsSignatureWithKey
import at.asitplus.wallet.lib.jws.VerifyJwsSignatureWithKeyFun
import at.asitplus.wallet.lib.oidvci.NonceService
import at.asitplus.wallet.lib.oidvci.OAuth2Exception.InvalidDpopProof
import at.asitplus.wallet.lib.oidvci.OAuth2Exception.InvalidToken
import at.asitplus.wallet.lib.oidvci.TokenInfo
import io.github.aakira.napier.Napier
import io.matthewnelson.encoding.core.Encoder.Companion.encodeToString
import kotlin.time.Clock
import kotlin.time.Clock.System
import kotlin.time.Duration
import kotlin.time.Duration.Companion.minutes


/**
 * Verifies access tokens and refresh tokens, that may have been generated by a [TokenGenerationService],
 * or by any other OAuth 2.0 authorization server.
 */
interface TokenVerificationService {

    /** Validates that this refresh token was actually issued by the known [TokenGenerationService]. */
    suspend fun validateRefreshToken(
        refreshToken: String,
        request: RequestInfo?,
    ): String

    /** Reads information about the token contained in [tokenOrAuthHeader] for token introspection. */
    suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo

    /** Validates the token (either plain token or from an HTTP `Authorization` header, i.e., with prefix). */
    suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
    ): KmmResult<Unit>
}

/**
 * Verifies JWT tokens that have been generated by [JwtTokenGenerationService], as [OpenId4VciAccessToken].
 *
 * Implemented from
 * [OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)
 */
class JwtTokenVerificationService(
    /** Used to verify nonces of tokens. */
    private val nonceService: NonceService,
    /** Used to verify the signature of the DPoP access token. */
    private val issuerKey: JsonWebKey,
    /** Used to verify client attestation JWTs */
    private val verifyJwsObject: VerifyJwsObjectFun = VerifyJwsObject(),
    /** Used to verify DPoP proofs */
    private val verifyJwsSignatureWithKey: VerifyJwsSignatureWithKeyFun = VerifyJwsSignatureWithKey(),
    /** Clock used to verify timestamps in access tokens and refresh tokens. */
    private val clock: Clock = System,
    /** Time leeway for verification of timestamps in access tokens and refresh tokens. */
    private val timeLeeway: Duration = 5.minutes,
) : TokenVerificationService {

    override suspend fun validateRefreshToken(
        refreshToken: String,
        request: RequestInfo?,
    ): String {
        val dpopTokenJwt = validateDpopToken(refreshToken, JwsContentTypeConstants.RT_JWT)
        validateDpopJwt(null, dpopTokenJwt, request)
        return refreshToken
    }

    override suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo = run {
        val dpopToken = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_DPOP, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_DPOP).split(" ").last()
        else tokenOrAuthHeader
        val dpopTokenJwt = validateDpopToken(dpopToken, JwsContentTypeConstants.OID4VCI_AT_JWT)
        val jwtId = dpopTokenJwt.payload.jwtId
            ?: throw InvalidToken("access token not valid: $dpopToken")
        // No need to validate DPoP JWT, because we are not granting access to anything, just printing infos
        with(dpopTokenJwt.payload) {
            TokenInfo(
                token = dpopToken,
                authorizationDetails = authorizationDetails?.filterIsInstance<OpenIdAuthorizationDetails>()?.toSet(),
                scope = scope
            )
        }
    }

    override suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
    ) = catching {
        val dpopToken = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_DPOP, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_DPOP).split(" ").last()
        else tokenOrAuthHeader
        val dpopTokenJwt = validateDpopToken(dpopToken, JwsContentTypeConstants.OID4VCI_AT_JWT)
        validateDpopJwt(null, dpopTokenJwt, httpRequest)
    }

    internal suspend fun validateDpopJwt(
        dpopToken: String?,
        dpopTokenJwt: JwsSigned<OpenId4VciAccessToken>,
        httpRequest: RequestInfo?,
    ) {
        if (httpRequest?.dpop.isNullOrEmpty()) {
            Napier.w("validateDpopJwt: No dpop proof in header")
            throw InvalidDpopProof("no dpop proof")
        }
        val jwt = parseAndValidate(httpRequest.dpop)
        if (dpopTokenJwt.payload.confirmationClaim == null ||
            jwt.header.jsonWebKey == null ||
            jwt.header.jsonWebKey!!.jwkThumbprintPlain != dpopTokenJwt.payload.confirmationClaim!!.jsonWebKeyThumbprint
        ) {
            Napier.w("validateDpopJwt: jwk not matching cnf.jkt")
            throw InvalidDpopProof("DPoP JWT JWK not matching cnf.jkt")
        }
        // Verify nonce, but where to get it?
        if (jwt.payload.httpTargetUrl != httpRequest.url) {
            Napier.w("validateDpopJwt: htu ${jwt.payload.httpTargetUrl} not matching requestUrl ${httpRequest.url}")
            throw InvalidDpopProof("DPoP JWT htu incorrect")
        }
        if (jwt.payload.httpMethod != httpRequest.method.value.uppercase()) {
            Napier.w("validateDpopJwt: htm ${jwt.payload.httpMethod} not matching requestMethod ${httpRequest.method}")
            throw InvalidDpopProof("DPoP JWT htm incorrect")
        }
        dpopToken?.let {
            val ath = dpopToken.encodeToByteArray().sha256().encodeToString(Base64UrlStrict)
            if (!jwt.payload.accessTokenHash.equals(ath)) {
                Napier.w("validateDpopJwt: ath expected $ath, was ${jwt.payload.accessTokenHash}")
                throw InvalidDpopProof("DPoP JWT ath not correct")
            }
        }
    }

    private suspend fun parseAndValidate(dpopHeader: String): JwsSigned<JsonWebToken> =
        JwsSigned.deserialize(JsonWebToken.serializer(), dpopHeader, vckJsonSerializer)
            .getOrElse {
                Napier.w("parse: could not parse DPoP JWT", it)
                throw InvalidDpopProof("could not parse DPoP JWT", it)
            }.also {
                if (!verifyJwsObject(it)) {
                    Napier.w("parse: DPoP not verified")
                    throw InvalidDpopProof("DPoP JWT not verified")
                }
            }

    internal suspend fun validateDpopToken(
        dpopToken: String,
        expectedType: String,
    ): JwsSigned<OpenId4VciAccessToken> {
        val jwt = JwsSigned
            .deserialize<OpenId4VciAccessToken>(OpenId4VciAccessToken.serializer(), dpopToken, vckJsonSerializer)
            .getOrElse {
                Napier.w("validateDpopToken: could not parse DPoP Token", it)
                throw InvalidToken("could not parse DPoP Token", it)
            }
        if (!verifyJwsSignatureWithKey(jwt, issuerKey)) {
            Napier.w("validateDpopToken: DPoP not verified")
            throw InvalidToken("DPoP Token not verified")
        }
        if (jwt.header.type != expectedType) {
            Napier.w("validateDpopToken: typ unexpected: ${jwt.header.type}")
            throw InvalidToken("typ not valid: ${jwt.header.type}")
        }
        if (jwt.payload.jwtId == null || !nonceService.verifyNonce(jwt.payload.jwtId!!)) {
            Napier.w("validateDpopToken: jti not known: ${jwt.payload.jwtId}")
            throw InvalidToken("jti not valid: ${jwt.payload.jwtId}")
        }
        if (jwt.payload.notBefore == null || jwt.payload.notBefore!! > (clock.now() + timeLeeway)) {
            Napier.w("validateDpopToken: nbf not valid: ${jwt.payload.notBefore}")
            throw InvalidToken("nbf not valid: ${jwt.payload.notBefore}")
        }
        if (jwt.payload.expiration == null || jwt.payload.expiration!! < (clock.now() - timeLeeway)) {
            Napier.w("validateDpopToken: exp not valid: ${jwt.payload.expiration}")
            throw InvalidToken("exp not valid: ${jwt.payload.expiration}")
        }
        if (jwt.payload.confirmationClaim == null) {
            Napier.w("validateDpopToken: no confirmation claim: $jwt")
            throw InvalidToken("no confirmation claim")
        }
        return jwt
    }

    private val JsonWebKey.jwkThumbprintPlain
        get() = this.jwkThumbprint.removePrefix("urn:ietf:params:oauth:jwk-thumbprint:sha256:")

}

/**
 * Verifies Bearer tokens that have been generated by [BearerTokenGenerationService].
 * This does only work for internal authorization servers, because we could not store the actual user data otherwise.
 */
class BearerTokenVerificationService(
    /** Loads the actual user data with [BearerTokenGenerationService.getValidatedAccessToken]. */
    internal val tokenGenerationService: BearerTokenGenerationService,
) : TokenVerificationService {

    override suspend fun validateRefreshToken(
        refreshToken: String,
        request: RequestInfo?,
    ): String {
        throw InvalidToken("Refresh tokens are not supported by this verifier")
    }

    override suspend fun validateAccessToken(
        tokenOrAuthHeader: String,
        httpRequest: RequestInfo?,
    ): KmmResult<Unit> = catching { getTokenInfo(tokenOrAuthHeader) }

    override suspend fun getTokenInfo(
        tokenOrAuthHeader: String,
    ): TokenInfo = run {
        val token = if (tokenOrAuthHeader.startsWith(TOKEN_TYPE_BEARER, ignoreCase = true))
            tokenOrAuthHeader.removePrefix(TOKEN_PREFIX_BEARER).split(" ").last()
        else tokenOrAuthHeader
        tokenGenerationService.verifyAccessToken(token)?.toTokenInfo()
            ?: throw InvalidToken("authorization header not valid: $tokenOrAuthHeader")
    }
}
